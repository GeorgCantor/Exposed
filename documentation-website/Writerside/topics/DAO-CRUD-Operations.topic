<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="CRUD Operations" id="DAO-CRUD-Operations">

    <p>The DAO (Data Access Object) API of Exposed, is similar to ORM frameworks like Hibernate with a Kotlin-specific API.</p>

    <chapter title="Create" id="create">
        <p>
            To create a new table row, use the <code>new</code> query.
        </p>
        <code-block lang="kotlin">
            val movie = StarWarsFilm.new {
                name = "The Last Jedi"
                sequelId = 8
                director = "Rian Johnson"
            }
        </code-block>
        <p>
            To provide a manual <code>id</code> value to a new entity, pass the value as an argument to the <code>id</code> parameter:
        </p>
        <code-block lang="kotlin">
            StarWarsFilm.new(id = 2) {
                name = "The Rise of Skywalker"
                sequelId = 9
                director = "J.J. Abrams"
            }
        </code-block>
        <p>
            If the entity is a <code>CompositeEntity</code>, the id value can be constructed by creating a component column-to-value association using
            <code>CompositeID</code>:
        </p>
        <code-block lang="kotlin">
            val newId = CompositeID {
                it[Directors.name] = "J.J. Abrams"
                it[Directors.guildId] = UUID.randomUUID()
            }

            Director.new(newId) {
                genre = Genre.SCI_FI
            }
        </code-block>
    </chapter>
    <chapter title="Read" id="read">
        <p>To get entities use one of the following methods:</p>

        <code-block lang="kotlin">
            val movies = StarWarsFilm.all()
            val movies = StarWarsFilm.find { StarWarsFilms.sequelId eq 8 }
            val movie = StarWarsFilm.findById(5)
        </code-block>
        <tip>
            For a list of available predicates, see
            <a href="DSL-Querying-data.topic" anchor="where-expression">DSL Where expression</a>.
        </tip>
        <p>Read a value from a property similar to any property in a Kotlin class:</p>

        <code-block lang="kotlin">
            val name = movie.name
        </code-block>
        <note>
            An entity's <code>id</code> property is wrapped as an instance of the <code>EntityID</code> class.
            To access the actual wrapped value, for example the stored <code>Int</code> from a <code>StarWarsFilm</code>
            entity, use <code>EntityID.value</code>:
            <code-block lang="kotlin">
                val id: Int = movie.id.value
            </code-block>
        </note>
        <p>
            If the entity is a <code>CompositeEntity</code>, its <code>id</code> property can be used to refer to
            all composite columns and to get entities,
            much like the <code>id</code> column of its associated <code>CompositeIdTable</code>:
        </p>

        <code-block lang="kotlin">
            val directorId = CompositeID {
                it[Directors.name] = "George Lucas"
                it[Directors.guildId] = "..."
            }

            // these will both deconstruct in SQL to the 2 component columns
            val director = Director.findById(directorId)
            val directors = Director.find { Directors.id eq directorId }
        </code-block>
    </chapter>
    <chapter title="Sort (Order-by)" id="sort-order-by">
        <p>Ascending order:</p>
        <code-block lang="kotlin">
            val movies = StarWarsFilm.all().sortedBy { it.sequelId }
        </code-block>
        <p>Descending order:</p>
        <code-block lang="kotlin">
            val movies = StarWarsFilm.all().sortedByDescending { it.sequelId }
        </code-block>
    </chapter>
    <chapter title="Update" id="update">
        <p>
            Update the value of a property similar to any property in a Kotlin class:
        </p>
        <code-block lang="kotlin">
            movie.name = &quot;Episode VIII – The Last Jedi&quot;
        </code-block>
        <note>
            Exposed doesn't make an immediate update when you set a new value for <code>Entity</code>, it just stores it on the inner map.
            "Flushing" values to the database occurs at the end of the transaction, or before the next <code>SELECT *</code> from the database.
        </note>
        <p>
            Search for an entity by its id and apply an update:
        </p>
        <code-block lang="kotlin">
            val updatedMovie = StarWarsFilm.findByIdAndUpdate(5) {
                it.name = &quot;Episode VIII – The Last Jedi&quot;
            }
        </code-block>
        <p>
            Search for a single entity by a query and apply an update:
        </p>
        <code-block lang="kotlin">
            val updatedMovie2 = StarWarsFilm.findSingleByAndUpdate(StarWarsFilms.name eq &quot;The Last Jedi&quot;) {
                it.name = &quot;Episode VIII – The Last Jedi&quot;
            }
        </code-block>
    </chapter>
    <chapter title="Delete" id="delete">
        <p>
            To delete a record, use the <code>delete()</code> function:
        </p>
        <code-block lang="kotlin">
            movie.delete()
        </code-block>
    </chapter>
    <chapter title="Read entity with a join to another table" id="read-entity-with-a-join-to-another-table">
        <p>Let's imagine that you want to find all users who rated second SW film with more than 5.
            First of all, we should write that query using Exposed DSL.</p>

        <code-block lang="kotlin">
            val query = Users.innerJoin(UserRatings).innerJoin(StarWarsFilm)
                .select(Users.columns)
                .where {
                    StarWarsFilms.sequelId eq 2 and (UserRatings.value gt 5)
                }.withDistinct()
        </code-block>
        <p>After that all we have to do is to wrap a result with <code>User</code> entity:</p>
        <code-block lang="kotlin">
            val users = User.wrapRows(query).toList()
        </code-block>
    </chapter>

    <chapter title="Use queries as expressions" id="use-queries-as-expressions">
        <p>Imagine that you want to sort cities by how many users each city has. In order to do so, you can write a
            sub-query which counts users in each city and
            order by that number. Though in order to do so you'll have to convert <code>Query</code> to
            <code>Expression</code>. This can be done using <code>wrapAsExpression</code>
            function:</p>
        <code-block lang="kotlin">
            val expression = wrapAsExpression&lt;Int&gt;(Users
                .select(Users.id.count())
                .where {
                    Cities.id eq Users.cityId
                })
            val cities = Cities
                .selectAll()
                .orderBy(expression, SortOrder.DESC)
                .toList()
        </code-block>
    </chapter>

    <chapter title="Add computed fields to entity class" id="add-computed-fields-to-entity-class">
        <p>Imagine that you want to use a window function to rank films with each entity fetch. The companion object of the entity class can override any open
            function in <code>EntityClass</code>, but to achieve this functionality only <code>searchQuery()</code> needs to
            be overriden. The results of the function can then be accessed using a property of the entity class:</p>

        <code-block lang="kotlin"><![CDATA[
            object StarWarsFilms : IntIdTable() {
                val sequelId = integer("sequel_id").uniqueIndex()
                val name = varchar("name", 50)
                val rating = double("rating")

                val rank = Rank().over().orderBy(rating, SortOrder.DESC)
            }

            class StarWarsFilm(id: EntityID<Int>) : IntEntity(id) {
                var sequelId by StarWarsFilms.sequelId
                var name by StarWarsFilms.name
                var rating by StarWarsFilms.rating

                val rank: Long
                    get() = readValues[StarWarsFilms.rank]

                companion object : IntEntityClass<StarWarsFilm>(StarWarsFilms) {
                    override fun searchQuery(op: Op<Boolean>): Query {
                        return super.searchQuery(op).adjustSelect {
                            select(columns + StarWarsFilms.rank).set
                        }
                    }
                }
            }

            transaction {
                StarWarsFilm.new {
                    sequelId = 8
                    name = "The Last Jedi"
                    rating = 4.2
                }
                // more insertions ...
                entityCache.clear()

                // fetch entities with value (or store entities then read value)
                StarWarsFilm.find { StarWarsFilms.name like "The%" }.map { it.name to it.rank }
            }
        ]]></code-block>
    </chapter>

    <chapter title="Auto-fill created and updated columns on entity change" id="auto-fill-created-and-updated-columns-on-entity-change">
        <p>See example by @PaulMuriithi <a href="https://github.com/PaulMuriithi/ExposedDatesAutoFill/blob/master/src/main/kotlin/app/Models.kt">here</a>.</p>
    </chapter>

</topic>
